===============================================================
Event-Driven Dependency Management with ``peak.events.trellis``
===============================================================

``peak.events.trellis`` is a dependency management framework for updating
values in a program.  When a value is changed, other values are automatically
updated, and code can be run to respond to value changes, somewhat like a
spreadsheet.

There are two things that are different from most other dependency-management
tools: synchronous updating, and automatic dependency discovery.

Synchronous updates means that all values are conceptually updated in lockstep,
such that there is never a time when the program's state is inconsistent due to
values being updated out of order.  In most event-driven systems, updates
are *asynchronous*, meaning that any value can change at any time, and some
values might change multiple times in response to a single input change,
leading to subtle bugs, especially as programs become more complex.

In contrast, synchronous updates ensure that every relevant value is updated
at most once for a change in a given input, making the system's dynamic
behavior easier to understand and far more likely to be bug-free.

Automatic dependency discovery means that there is no need to explicitly
"subscribe" or "listen" to anything.  Values that use other values in their
calculations automatically become dependent on the values they use.  If a
subsequent recalculation results in a new dependency relationship, that's kept
up-to-date also.

The concepts and algorithms used are courtesy of two systems, the "trellis
process architecture" described by David Gelernter in his book, "Mirror
Worlds", and the Lisp "Cells" library by Ken Tilton.  ``peak.events.trellis``
also takes some of its terminology from the Smalltalk "Value Model" frameworks.


.. contents:: **Table of Contents**


--------------
Programmer API
--------------


Cell Objects
=============

``Cell`` objects are the basis of the framework.  Each holds a value upon
which other values may depend.  There are two basic value types, ``Cell`` and
``Constant``::

    >>> from peak.events.trellis import Cell, Constant
    
``Cell`` objects can hold a value::

    >>> v = Cell(value=42)
    >>> v.value
    42

or use a *rule* to determine their value::

    >>> v_times_two = Cell(rule=lambda: v.value * 2)
    >>> v_times_two.value
    84

And that value always reflects the current values of any values that it depends
on::

    >>> v.value = 23
    >>> v_times_two.value
    46

``Constant`` values are initialized with a value, and are unchangeable
thereafter::

    >>> c = Constant(99)
    >>> c.value
    99
    >>> c.value -= 1
    Traceback (most recent call last):
      ...
    AttributeError: Constants can't be changed

Most of the time you won't use ``Constant`` objects directly, though, because
if a ``Cell`` has a rule but no initial value, it becomes a ``ReadOnlyCell``,
and if at some point it no longer depends on any other cell, it becomes
a ``Constant`` automatically after the next time it's read::

    >>> def rule():
    ...     print "computing"
    ...     return 1
    
    >>> c = Cell(rule)
    >>> c.value
    computing
    1
    >>> c   # The rule didn't use any other cells, so we need never recalculate
    Constant(1)

Writing a new cell's value should not require a new pulse::

    >>> def rule():
    ...     c = Cell(value=99)
    ...     c.value = 42
    ...     return c.value
    >>> Cell(rule).value
    42


Demos
-----

Circular calculations::

    >>> F = Cell(lambda: C.value*1.8 + 32, 32)
    >>> C = Cell(lambda: (F.value-32)/1.8, 0)
    >>> F.value
    32.0
    >>> C.value
    0.0
    >>> F.value = 212
    >>> C.value
    100.0
    >>> C.value = 0
    >>> F.value
    32.0
    >>> C.value = -40
    >>> F.value
    -40.0

    >>> def temp():
    ...     if C.value<10:
    ...         print "Brrrrr!"
    >>> temp = Cell(temp)
    >>> temp.value
    Brrrrr!

    >>> F.value = 212
    >>> C.value
    100.0
    >>> F.value = 0
    Brrrrr!
    >>> C.value = 9
    Brrrrr!
    >>> F.value = 30
    Brrrrr!    

    >>> del temp

Spreadsheet simulation::

    >>> from UserDict import DictMixin, UserDict
    >>> import sys
    >>> class Spreadsheet(DictMixin, UserDict):
    ...     def __init__(self, *args, **kw):
    ...         self.data = {}
    ...         for arg in args+(kw,): self.update(arg)
    ...
    ...     def __getitem__(self, key):
    ...         return self.data[key][1].value
    ...
    ...     def __setitem__(self, key, value):
    ...         def rule():
    ...             value = self.data[key][0].value
    ...             print "computing", value
    ...             if sys.version>="2.4":
    ...                 return eval(value, globals(), self)
    ...             code = compile(value, '<string>', 'eval')
    ...             d = dict([(k,self[k]) for k in code.co_names if k in self.data])
    ...             return eval(code, globals(), d)
    ...         if key in self.data:
    ...             self.data[key][0].value = value
    ...         else:
    ...             self.data[key] = Cell(value=value), Cell(rule, None)

    >>> ss = Spreadsheet()
    >>> ss['a1'] ='5'
    >>> ss['a2']='2*a1'
    >>> ss['a3']='2*a2'
    
    >>> ss['a1']
    computing 5
    5
    >>> ss['a2']
    computing 2*a1
    10

    >>> ss['a1'] = '7'
    computing 7
    computing 2*a1

    >>> ss['a1']
    7
    >>> ss['a2']
    14
    >>> ss['a3']
    computing 2*a2
    28

    >>> ss['a1'] = '3'
    computing 3
    computing 2*a1
    computing 2*a2

Events::

    >>> def last_ping():
    ...     if ping.value is not None:
    ...         print "ping", ping.value
    ...         return ping.value
    ...     return last_ping.value

    >>> last_ping = Cell(last_ping)
    >>> ping = Cell(discrete=True)

    >>> print last_ping.value
    None

    >>> ping.value = 1
    ping 1
    >>> last_ping.value
    1

    >>> F.value = 27
    >>> print ping.value    # value goes away as soon as something changes
    None
    >>> last_ping.value
    1

    >>> ping.value = 2     
    ping 2
    >>> last_ping.value
    2
    >>> ping.value = 2      # deps are recalculated even if value is same
    ping 2

    >>> F.value = 99
    >>> print ping.value
    None
    >>> last_ping.value
    2

    
-------------------
Internals and Tests
-------------------



Update Algorithm
================

A value must be computed if and only if it is out of date; otherwise, it should
just return its previous cached value.  A value is out of date if a
value it depends on has changed since the value was last calculated.  The
``pulse`` attribute tracks the version the value was last calculated "as of",
and the ``needs`` attribute records the latest version of any value this value
depends on.  If ``needs>=pulse``, the value is out of date::

    >>> x = Cell(value=23)
    >>> def rule():
    ...     print "computing y from x"
    ...     return x.value * 2
    >>> y = Cell(rule)
    >>> y.value
    computing y from x
    46

    >>> y.value
    46

    >>> x.value = 10
    computing y from x
    >>> y.value
    20

    >>> x.value = 10
    >>> y.value
    20

    >>> def rule2():
    ...     print "computing z from y"
    ...     return y.value - 1
    >>> z = Cell(rule2)
    >>> z.value
    computing z from y
    19

    >>> x.value = 7
    computing y from x
    computing z from y


When a value changes, the values that depend on it must be brought up to date.
To ensure that no stale values can ever be seen, values must be marked
"out of date" before any values are recomputed.  Thus, update notification
has two phases: first, the listeners of a value are marked out-of-date, and
only then does recomputation occur.  This breadth-first traversal ensures that
inter-value dependencies can't cause a stale value to be seen, as might happen
if updates were done depth-first.

A value must not be marked out of date using a dependency that no longer
exists, however.  For example, if a value C depends on values A and B, and A
changes, then later B, the change to B should not mark C out-of-date unless
a new dependency was set up.

    >>> def C_rule():
    ...     print "computing",
    ...     if A.value<5:
    ...         print A.value, B.value
    ...     else:
    ...         print "...done"

    >>> A = Cell(value=1)
    >>> B = Cell(value=2)
    >>> C = Cell(C_rule)

    >>> C.value
    computing 1 2
    >>> C.value

    >>> A.value = 3
    computing 3 2

    >>> B.value = 4
    computing 3 4

    >>> A.value = 5
    computing ...done

    >>> B.value = 6     # nothing happens, since C no longer depends on B
    >>> A.value = 3
    computing 3 6

    >>> B.value = 7     # but now it's back depending on B again.
    computing 3 7

    >>> B.value = 7
    >>> A.value = 1
    computing 1 7

    >>> A.value = 1


Forcing a rule to repeat itself::

    >>> from peak.events.trellis import repeat, ReadOnlyCell
    >>> def counter():
    ...     if counter.value == 10:
    ...         return counter.value
    ...     repeat()
    ...     return counter.value + 1
    >>> counter = ReadOnlyCell(counter, 1)
    >>> counter.value
    10

(It does nothing if invoked outside of an executing rule.)


TODO
====

* Allow custom comparison function for "changedness"

* Rollback



Feature Comparisons
-------------------

+-----------------------------------------+---------+---------+-----------+
| Feature                                 | Trellis | PyCells | Cellulose |
+=========================================+=========+=========+===========+
| Mutually-recursive/circular rules       | YES     | NO      | NO        |
+-----------------------------------------+---------+---------+-----------+
| Changed rules get recalculated ASAP     | YES     | NO [1]_ | ?         |
+-----------------------------------------+---------+---------+-----------+
| Cells can be used independently,        | YES     | NO      | YES       |
| without attachment to an "owner" or     |         |         |           |
| other object                            |         |         |           |
+-----------------------------------------+---------+---------+-----------+
| Only one constructor needed for all     | YES     | NO [2]_ | NO        |
| cell types?                             |         |         |           |
+-----------------------------------------+---------+---------+-----------+
| Observers/side-effects allowed directly | YES     | NO      | ?         |
| in rules?                               |         |         |           |
+-----------------------------------------+---------+---------+-----------+
| "Ephemeral" or "discrete" cells         | YES     | YES     | NO        |
+-----------------------------------------+---------+---------+-----------+
| Threading model [3]_                    | Free    | Free    | Blocking  |
+-----------------------------------------+---------+---------+-----------+
| Pluggable event loop support            | YES     | NO      | NO        |
+-----------------------------------------+---------+---------+-----------+
| Minimum memory requirement for each     | 88      | 164     | 632       |
| cell object, not including rules or     |         |         |           |
| contents, measured in bytes of          |         |         |           |
| ``__basicsize__`` at initialization     |         |         |           |
| time                                    |         |         |           |
+-----------------------------------------+---------+---------+-----------+
| Conflict detection/race prevention      | YES     | NO      | NO        |
| (Ensures that multiple sets to same     |         |         |           |
| cell within one propagation pulse       |         |         |           |
| must match, preventing any ordering     |         |         |           |
| dependencies from sneaking in.)         |         |         |           |
+-----------------------------------------+---------+---------+-----------+
| Easy construction of "model" objects    | Soon    | YES     | YES       |
+-----------------------------------------+---------+---------+-----------+
| Data structure types included           | Soon    | YES     | YES       |
+-----------------------------------------+---------+---------+-----------+


.. [1] See http://lateral.netmanagers.com.ar/weblog/2007/05/22.html for an
       example of the problem; Trellis successfully handles this example.

.. [2] PyCells has a single cell *attribute* constructor, makecell; but 

.. [3] Trellis and PyCells allow threads to freely operate on *separate* sets
       of cells without blocking -- the so-called "shared nothing" model.
       Cellulose has locking code that allows cells to be shared between
       threads, but even single-threaded code pays the price of locking.
       Trellis (and in principle PyCells) can communicate between threads using
       ``Queue.Queue`` objects to link one thread's cells to those of another.



