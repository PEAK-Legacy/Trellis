Cell Properties
---------------

Cell properties are descriptors used to implement cell-based attributes.  They
are created using a name::

    >>> from peak.events.trellis import Cell, CellProperty

    >>> CellProperty('C')
    CellProperty('C')

And they compare equal only to other cell properties with the same name::

    >>> CellProperty('C') == CellProperty('C')
    True
    >>> CellProperty('C') != CellProperty('F')
    True
    >>> CellProperty('C') != 'C'
    True
    >>> CellProperty('C') == CellProperty('F')
    False
    >>> CellProperty('C') != CellProperty('C')
    False
    >>> CellProperty('C') == 'C'
    False

When used as descriptors in a class, they read or write the ``.value``
attribute of the corresponding cell in the object's ``__cells__`` dictionary::

    >>> class Converter(object):
    ...     C = CellProperty('C')
    ...     F = CellProperty('F')
    ...     def __init__(self):
    ...         self.__cells__ = dict(
    ...             F = Cell(lambda: self.C * 1.8 + 32, 32),
    ...             C = Cell(lambda: (self.F - 32)/1.8, 0),
    ...         )

    >>> Converter.C
    CellProperty('C')
    
    >>> tc = Converter()
    >>> tc.C
    0
    >>> tc.F
    32

    >>> tc.C = 100
    >>> tc.F
    212.0

Setting a CellProperty-mediated attribute to a ``Cell`` instance, replaces
that instance in the ``__cells__`` dictionary::

    >>> tc.F = Cell(lambda: -tc.C)
    >>> tc.F
    -100

Getting or setting a cell attribute that has no cell in the object's
``__cells__`` invokes the registered factory function for cell creation::

    >>> from peak.events.trellis import CellFactories
    >>> def demo_factory(typ, ob, name):
    ...     print "Creating", name, "cell for", typ, "instance"
    ...     return Cell(lambda: ob.C*2, 0)

    >>> CellFactories(Converter)['F'] = demo_factory
    >>> del tc.__cells__['F']
    >>> tc.F
    Creating F cell for <class 'Converter'> instance
    200
    >>> tc.F = 42
    
    >>> del tc.__cells__['F']
    >>> tc.F = 27
    Creating F cell for <class 'Converter'> instance
    >>> tc.F
    27

    >>> tc.F = Cell(lambda: -tc.C)
    >>> tc.F
    -100

Cell factories are inherited by subclasses::

    >>> class Converter2(Converter):
    ...     pass
    >>> tc2 = Converter2()
    >>> del tc2.__cells__['F']
    >>> tc2.F = 27
    Creating F cell for <class 'Converter2'> instance
    >>> tc2.F
    27


TodoProperty
------------

TodoProperty objects are like CellProperty, but offer an extra ``future``
attribute::

    >>> from peak.events.trellis import TodoProperty, todo_factory
    
    >>> class X(object):
    ...     x = TodoProperty('x')
    ...     future_x = x.future
    >>> help(X)
    Help on class X in module __builtin__:
    <BLANKLINE>
    class X(object)
     |  ...
     |  future_x
     |      The future value of the 'x' attribute...
     |  x...
     |      Property representing a ``todo`` attribute
    <BLANKLINE>


    >>> TodoProperty('x')==TodoProperty('y')
    False
    >>> TodoProperty('x')==CellProperty('x')
    False
    >>> TodoProperty('x')!=TodoProperty('x')
    False

    >>> TodoProperty('x')==TodoProperty('x')
    True
    >>> TodoProperty('x')!=TodoProperty('y')
    True
    >>> TodoProperty('x')!=CellProperty('x')
    True
    

Class Metadata
--------------

    >>> from peak.events.trellis import CellRules, CellValues, IsReceiver
    >>> from peak.events.trellis import IsOptional, default_factory, NO_VALUE
    >>> from peak.events.trellis import *

Setting a value in CellRules or CellValues sets the same value in CellFactories
to default_factory::

    >>> class Test(object):
    ...     x = rule(lambda self: 27)
    ...     values(y = 42)

    >>> CellRules(Test)
    {'x': <function <lambda> at ...>}

    >>> CellValues(Test)
    {'y': 42}

    >>> CellFactories(Test)
    {'y': <function default_factory at ...>,
     'x': <function default_factory at ...>}

    >>> Test.x
    CellProperty('x')

    >>> Test.y
    CellProperty('y')

    >>> default_factory(Test, Test(), 'y')
    Cell(None, 42)

    >>> t = Test()
    >>> t.__cells__ = {}

    >>> t.x
    27

    >>> t.__cells__['x']
    Constant(27)

    
IsOptional and IsReceiver default to false for any attribute that has an
explicit setting defined in a given class in any other registry besides
themselves::

    >>> IsOptional(Test)
    {'y': False, 'x': False}

    >>> IsReceiver(Test)
    {'y': False, 'x': False}
  
The default_factory handles _sentinel values by not passing them to the Cell
constructor::

    >>> CellRules(Test)['x'] = None
    >>> CellValues(Test)['x'] = NO_VALUE
    >>> default_factory(Test, Test(), 'x')
    Cell(None, None)

And it binds non-None rules to the instance::

    >>> CellRules(Test)['x'] = lambda self: 42
    >>> default_factory(Test, Test(), 'x')
    ReadOnlyCell(<bound method Test.<lambda> of <Test object at...>>, 42)
    
And uses the event flag from IsReceiver::

    >>> CellRules(Test)['x'] = None
    >>> IsReceiver(Test)['x'] = True
    >>> default_factory(Test, Test(), 'x')
    Cell(None, None, receiver[None])

The todo_factory only uses the rule to create the default value, and always
creates a rule-free receiver, regardless of the value or receiver flag
settings::

    >>> CellRules(Test)['x'] = lambda self: dict()
    >>> CellValues(Test)['x'] = 54
    >>> IsReceiver(Test)['x'] = False

    >>> Test.x = TodoProperty('x')
    >>> Test.to_x = Test.x.future

    >>> todo_factory(Test, Test(), 'x')
    Cell(None, {}, receiver[{}])


future, @modifier, etc.
-----------------------

    >>> t = Test()
    >>> t.__cells__ = {}

    >>> def dump(): print "t.x =", t.x

    >>> watcher = Cell(dump)
    >>> watcher.value
    t.x = {}

    >>> t.to_x
    Traceback (most recent call last):
      ...
    RuntimeError: future can only be accessed from a @modifier
    
    >>> def add(key, val):
    ...     t.to_x[key] = val
    >>> add = modifier(add)

    >>> add(1, 2)
    t.x = {1: 2}
    
    >>> def update(**kw):
    ...     for k, v in kw.items():
    ...         add(k, v)

    >>> update(x=1, y=2)
    t.x = {'y': 2}
    t.x = {'x': 1}

    >>> update = modifier(update)

    >>> update(x=1, y=2)    # it all happens in one go
    t.x = {'y': 2, 'x': 1}



    

Decorators
----------

    >>> from peak.util.decorators import decorate
    
    >>> class Test:
    ...     def aRule(self):
    ...         return 42
    ...     r = rule(aRule)   # trick to exercise auto-name-finding
    ...     anEvent = receiver(-1)
    ...     optRule = optional(lambda:99)
    ...     todo = todo(lambda self:{})

    >>> Test.r
    CellProperty('aRule')

    >>> Test.todo
    TodoProperty('todo')
    
    >>> CellRules(Test)
    {'anEvent': None,
     'optRule': <function <lambda> at...>,
     'aRule': <function aRule at...>, 'todo': <function <lambda> at ...>}

    >>> CellValues(Test)
    {'anEvent': -1, 'todo': None}

    >>> IsReceiver(Test)
    {'anEvent': True, 'optRule': False, 'aRule': False, 'todo': True}

    >>> CellFactories(Test)
    {'anEvent': <function default_factory...>,
     'aRule': <function default_factory...>,
     'todo': <function todo_factory...>}

    >>> IsOptional(Test)     
    {'anEvent': False, 'optRule': True, 'aRule': False, 'todo': False}


    >>> class Test(object):
    ...     todos(
    ...         added   = lambda self:{},
    ...         removed = lambda self:set()
    ...     )
    ...     to_add = added.future
    ...     to_remove = removed.future

    >>> CellRules(Test)
    {'removed': <function <lambda> at...>,
     'added': <function <lambda> at ...>}

    >>> CellValues(Test)
    {'removed': None, 'added': None}

    >>> IsReceiver(Test)
    {'removed': True, 'added': True}

    >>> CellFactories(Test)
    {'removed': <function todo_factory...>,
     'added': <function todo_factory...>}


Error messages::

    >>> class Test:
    ...     decorate(rule, optional)
    ...     def wrong(): pass
    Traceback (most recent call last):
      ...
    TypeError: @rule decorator must wrap a function directly

    >>> class Test:
    ...     decorate(todo, optional)
    ...     def wrong(): pass
    Traceback (most recent call last):
      ...
    TypeError: @todo decorator must wrap a function directly


Components
----------

    >>> def hello(msg):
    ...     print msg
    
    >>> class Test(Component):
    ...     rules(
    ...         X = lambda self: self.Y + 2
    ...     )
    ...     receivers(Y = 0)
    ...     Z = value(0)
    ...     def always(self):
    ...         print "always!"
    ...     always = rule(always)    
    ...     def only_on_request(self):
    ...         print "hello!"
    ...     only_on_request = optional(only_on_request)
    ...     A=optional(lambda s:hello("A!"))
    ...     rules(B=lambda s:hello("B!"))
    

    >>> IsReceiver(Test)
    {'A': False, 'B': False, 'always': False, 'only_on_request': False,
     'Y': True, 'X': False, 'Z': False}


Non-optional attributes are activated at creation time, as are the appropriate
cells::

    >>> t = Test()
    B!
    always!

    >>> t.__cells__.keys()
    ['Y', 'always', 'Z', 'B', 'X']
    
    >>> t.only_on_request
    hello!

    >>> t.A
    A!
    >>> t.A
    
    >>> t.X
    2
    >>> t.Y = 23
    >>> t.X
    2
    >>> t.Z = 1
    >>> t.X
    2

    >>> def show_X():
    ...     print "X =", t.X
    >>> show_X = Cell(show_X)
    >>> show_X.value
    X = 2

    >>> t.Y = 23
    X = 25
    X = 2

    >>> t.__cells__.keys()
    ['A', 'B', 'always', 'only_on_request', 'Y', 'X', 'Z']    

Keyword arguments are accepted by the constructor::

    >>> t = Test(always=Constant(False), B=Constant(0), Z=55)
    >>> t.Z
    55
    >>> t.B
    0
    >>> t.always
    False

But not for undefined attributes::

    >>> t = Test(qqqq=42)
    Traceback (most recent call last):
      ...
    TypeError: Test() has no keyword argument 'qqqq'


Creating a component from within a rule should not create a dependency link to
the rule::

    >>> x = Cell(value=27)
    >>> class Test(Component):
    ...     rules(x = lambda self: x.value)
    >>> def rule():
    ...     print "creating"
    ...     Test()
    >>> r = Cell(rule)
    >>> r.value
    creating
    >>> x.value = 99

And initializing a component cell that would ordinarily be read-only, should
replace it with a constant::

    >>> class Test(Component):
    ...     rules(x = lambda self: {})
    >>> t = Test(x=())
    >>> t.__cells__['x']
    Constant(())

XXX better error message for write to read-only cell


Cell Objects
------------

get_value/set_value methods::

    >>> c = Cell()
    >>> print c.get_value()
    None
    >>> c.set_value(42)
    >>> c.value
    42
    >>> c1 = Constant(42)
    >>> c1.get_value()
    42
    >>> c1.set_value(99)
    Traceback (most recent call last):
      ...
    AttributeError: 'Constant' object has no attribute 'set_value'

    >>> c1 = Cell(lambda: c.value)
    >>> c1.get_value()
    42
    >>> c1.set_value(99)
    Traceback (most recent call last):
      ...
    AttributeError: 'ReadOnlyCell' object has no attribute 'set_value'

    >>> c.set_value(99)
    >>> c1.get_value()
    99
    

Repeating, Polling, Recalc
--------------------------

    >>> poll()
    Traceback (most recent call last):
      ...
    RuntimeError: poll() must be called from a rule

    >>> repeat()
    Traceback (most recent call last):
      ...
    RuntimeError: repeat() must be called from a rule

    >>> c = Cell(value=99)
    >>> c.ensure_recalculation()
    Traceback (most recent call last):
      ...
    TypeError: Can't recalculate a cell without a rule

    >>> def hello(): print "c =", c.value
    >>> c1 = Cell(hello)
    
    >>> Cell(c1.ensure_recalculation).value
    c = 99

    >>> c.value = 42
    c = 42

    >>> Cell().value = 76
    >>> c1.ensure_recalculation()
    >>> Cell().value
    c = 42

    >>> Cell().value = 69
    >>> c1.ensure_recalculation()
    >>> Cell().value
    c = 42

    >>> c1.value
    >>> c1.ensure_recalculation()
    Traceback (most recent call last):
      ...
    RuntimeError: Already recalculated
  
    >>> Cell().value = 1    # already calculated, no effect

    >>> c1.ensure_recalculation()
    >>> Cell().value
    c = 42

"Poll" re-invokes a rule on the next recalc of *anything*::

    >>> Cell().value = 21
    >>> c1.ensure_recalculation()

    >>> def count():
    ...     if poll(): print "calculating"
    ...     return c.value+1

    >>> c = Cell(count, 0)
    >>> c.value
    calculating
    c = 1
    1
    >>> c.value
    1

    >>> Cell().value = 16
    calculating
    c = 2
    
    >>> Cell().value = 7
    calculating
    c = 3

    >>> Cell().value = 66
    calculating
    c = 4


At least, until/unless you get rid of the cell::

    >>> c = Cell(value=99)
    >>> c.value
    99

Which of course requires that its listeners drop their references first::

    >>> Cell().value = 27
    calculating
    c = 99

And now the repeated polling of the now-vanished cell stops::

    >>> Cell().value = 66
    >>> c.value = 20
    c = 20    

