Cell Properties
---------------

Cell properties are descriptors used to implement cell-based attributes.  They
are created using a name::

    >>> from peak.events.trellis import Cell, CellProperty

    >>> CellProperty('C')
    CellProperty('C')

And they compare equal only to other cell properties with the same name::

    >>> CellProperty('C') == CellProperty('C')
    True
    >>> CellProperty('C') != CellProperty('F')
    True
    >>> CellProperty('C') != 'C'
    True
    >>> CellProperty('C') == CellProperty('F')
    False
    >>> CellProperty('C') != CellProperty('C')
    False
    >>> CellProperty('C') == 'C'
    False

When used as descriptors in a class, they read or write the ``.value``
attribute of the corresponding cell in the object's ``__cells__`` dictionary::

    >>> class Converter(object):
    ...     C = CellProperty('C')
    ...     F = CellProperty('F')
    ...     def __init__(self):
    ...         self.__cells__ = dict(
    ...             F = Cell(lambda: self.C * 1.8 + 32, 32),
    ...             C = Cell(lambda: (self.F - 32)/1.8, 0),
    ...         )

    >>> Converter.C
    CellProperty('C')
    
    >>> tc = Converter()
    >>> tc.C
    0
    >>> tc.F
    32

    >>> tc.C = 100
    >>> tc.F
    212.0

Setting a CellProperty-mediated attribute to a ``Cell`` instance, replaces
that instance in the ``__cells__`` dictionary::

    >>> tc.F = Cell(lambda: -tc.C)
    >>> tc.F
    -100

Getting or setting a cell attribute that has no cell in the object's
``__cells__`` invokes the registered factory function for cell creation::

    >>> from peak.events.trellis import CellFactories
    >>> def demo_factory(typ, ob, name):
    ...     print "Creating", name, "cell for", typ, "instance"
    ...     return Cell(lambda: ob.C*2, 0)

    >>> CellFactories(Converter)['F'] = demo_factory
    >>> del tc.__cells__['F']
    >>> tc.F
    Creating F cell for <class 'Converter'> instance
    200
    >>> tc.F = 42
    
    >>> del tc.__cells__['F']
    >>> tc.F = 27
    Creating F cell for <class 'Converter'> instance
    >>> tc.F
    27

    >>> tc.F = Cell(lambda: -tc.C)
    >>> tc.F
    -100

Cell factories are inherited by subclasses::

    >>> class Converter2(Converter):
    ...     pass
    >>> tc2 = Converter2()
    >>> del tc2.__cells__['F']
    >>> tc2.F = 27
    Creating F cell for <class 'Converter2'> instance
    >>> tc2.F
    27


Class Metadata
--------------

    >>> from peak.events.trellis import CellRules, CellValues, EventFlags
    >>> from peak.events.trellis import IsOptional, default_factory
    >>> from peak.events.trellis import *

Setting a value in CellRules or CellValues sets the same value in CellFactories
to default_factory::

    >>> class Test:
    ...     x = rule(lambda self: 27)
    ...     y = value(42)

    >>> CellRules(Test)
    {'x': <function <lambda> at ...>}

    >>> CellValues(Test)
    {'y': 42}

    >>> CellFactories(Test)
    {'y': <function default_factory at ...>,
     'x': <function default_factory at ...>}

    >>> Test.x
    CellProperty('x')

    >>> Test.y
    CellProperty('y')

    >>> default_factory(Test, Test(), 'y')
    Cell(None, 42)

    >>> t = Test()
    >>> t.__cells__ = {}

    >>> t.x
    27

    >>> t.__cells__['x']
    Constant(27)

    
IsOptional and EventFlags default to false for any attribute that has an
explicit setting defined in a given class in any other registry besides
themselves::

    >>> IsOptional(Test)
    {'y': False, 'x': False}

    >>> EventFlags(Test)
    {'y': False, 'x': False}

Setting a CellFactory sets the rule to None, event to False, and value to
_sentinel::

    >>> class Test(object):
    ...     cell_factories(x=lambda self: Cell(value=27))

    >>> EventFlags(Test)
    {'x': False}

    >>> CellRules(Test)
    {'x': None}

    >>> CellValues(Test)
    {'x': NO_VALUE}

    >>> CellFactories(Test)
    {'x': Factory(<function <lambda> at ...>,)}

    >>> t = Test()
    >>> t.__cells__ = {}

    >>> t.x
    27

    >>> t.__cells__['x']
    Cell(None, 27)

   
The default_factory handles _sentinel values by not passing them to the Cell
constructor::

    >>> default_factory(Test, Test(), 'x')
    Cell(None, None)

And it binds non-None rules to the instance::

    >>> CellRules(Test)['x'] = lambda self: 42
    >>> default_factory(Test, Test(), 'x')
    ReadOnlyCell(<bound method Test.<lambda> of <Test object at...>>, 42)
    
And uses the event flag from EventFlags::

    >>> EventFlags(Test)['x'] = True
    >>> default_factory(Test, Test(), 'x')
    ReadOnlyCell(<bound method ... of <Test object at...>>, 42, event[None])
    

Decorators
----------

    >>> from peak.util.decorators import decorate
    
    >>> class Test:
    ...     def aRule(self):
    ...         return 42
    ...     print rule(aRule)   # trick to exercise auto-name-finding
    ...     anEvent = event(lambda:27, -1)
    ...     optRule = optional(lambda:99)
    CellProperty('aRule')
    
    >>> CellRules(Test)
    {'anEvent': <function <lambda> at...>,
     'optRule': <function <lambda> at...>,
     'aRule': <function aRule at...>}

    >>> CellValues(Test)
    {'anEvent': -1}

    >>> EventFlags(Test)
    {'anEvent': True, 'optRule': False, 'aRule': False}

    >>> CellFactories(Test)
    {'anEvent': <function default_factory...>,
     'aRule': <function default_factory...>}

    >>> IsOptional(Test)     
    {'anEvent': False, 'optRule': True, 'aRule': False}

stacking optional on a rule::

    >>> class Test:
    ...     decorate(optional, rule)
    ...     def optRule2(self):
    ...         return "spam"

    >>> IsOptional(Test)
    {'optRule2': True}

    >>> CellRules(Test)
    {'optRule2': <function optRule2 at...>}

    >>> CellFactories(Test)
    {'optRule2': <function default_factory at...>}

    >>> EventFlags(Test)
    {'optRule2': False}
    
    >>> CellValues(Test)
    {}

    >>> class Test:
    ...     def optRule2(self):
    ...         return "spam"
    ...     optRule2 = optional( rule(optRule2) )
    ...     optRule1 = optional( rule(lambda self: 99) )

    >>> IsOptional(Test)
    {'optRule2': True, 'optRule1': True}

    >>> CellRules(Test)
    {'optRule2': <function optRule2 ...>, 'optRule1': <function <lambda> ...>}

    >>> CellFactories(Test)
    {'optRule2': <function default_factory at...>,
     'optRule1': <function default_factory at...>}

    >>> EventFlags(Test)
    {'optRule2': False, 'optRule1': False}

    >>> CellValues(Test)
    {}

stacking event on a rule::

    >>> class Test:
    ...     decorate(event, rule)
    ...     def evtRule2(self):
    ...         return "spam"

    >>> EventFlags(Test)
    {'evtRule2': True}

    >>> IsOptional(Test)
    {'evtRule2': False}

    >>> CellRules(Test)
    {'evtRule2': <function evtRule2 at...>}

    >>> CellFactories(Test)
    {'evtRule2': <function default_factory at...>}

    >>> CellValues(Test)
    {}

    >>> class Test:
    ...     def evtRule2(self):
    ...         return "spam"
    ...     evtRule2 = event( rule(evtRule2) )
    ...     evtRule1 = event( rule(lambda self: 99) )

    >>> EventFlags(Test)
    {'evtRule2': True, 'evtRule1': True}

    >>> CellRules(Test)
    {'evtRule2': <function evtRule2 ...>, 'evtRule1': <function <lambda> ...>}

    >>> CellFactories(Test)
    {'evtRule2': <function default_factory at...>,
     'evtRule1': <function default_factory at...>}

    >>> IsOptional(Test)
    {'evtRule2': False, 'evtRule1': False}

    >>> CellValues(Test)
    {}

    >>> class Test:
    ...     def evtRule2(self):
    ...         return "spam"
    ...     rules(event,
    ...         evtRule2 = evtRule2,
    ...         evtRule1 = lambda self: 99
    ...     )
    ...     cell_factories(optional, foo=lambda self:Constant(42))
    ...
    ...     decorate(cell_factory)
    ...     def factory(self): return Constant(81)

    >>> EventFlags(Test)
    {'evtRule2': True, 'evtRule1': True, 'factory': False, 'foo': False}

    >>> CellRules(Test)
    {'evtRule2': <function evtRule2 ...>,
     'evtRule1': <function <lambda> ...>,
     'factory': None, 'foo': None}

    >>> CellFactories(Test)
    {'evtRule2': <function default_factory at...>,
     'evtRule1': <function default_factory at...>,
     'factory': Factory(<function factory at...>,),
     'foo': Factory(<function <lambda> at...>,)}

    >>> IsOptional(Test)
    {'evtRule2': False, 'evtRule1': False, 'factory': False, 'foo': True}

    >>> CellValues(Test)
    {'foo': NO_VALUE, 'factory': NO_VALUE}

Error messages::

    >>> class Test:
    ...     decorate(rule, event)
    ...     def wrong(): pass
    Traceback (most recent call last):
      ...
    TypeError: rule decorator must wrap a function directly

    >>> class Test:
    ...     decorate(cell_factory, optional)
    ...     def wrong(): pass
    Traceback (most recent call last):
      ...
    TypeError: cell_factory decorator must wrap a function directly

    >>> class Test:
    ...     decorate(value, rule)
    ...     def wrong(): pass
    Traceback (most recent call last):
      ...
    TypeError: value() must wrap a value directly


Components
----------

    >>> def hello(msg):
    ...     print msg
    
    >>> class Test(Component):
    ...     rules(
    ...         X = lambda self: self.Y + 2
    ...     )
    ...     values(event, X = 0, Y = 0, Z = 0)
    ...     def always(self):
    ...         print "always!"
    ...     always = rule(always)    
    ...     def only_on_request(self):
    ...         print "hello!"
    ...     only_on_request = optional(only_on_request)
    ...     events(optional, A=lambda s:hello("A!"))
    ...     events(B=lambda s:hello("B!"))

    >>> EventFlags(Test)
    {'A': True, 'B': True, 'always': False, 'only_on_request': False,
     'Y': True, 'X': True, 'Z': True}


Non-optional attributes are activated at creation time, as are the appropriate
cells::

    >>> t = Test()
    B!
    always!

    >>> t.__cells__.keys()
    ['Y', 'always', 'Z', 'B', 'X']
    
    >>> t.only_on_request
    hello!

    >>> t.A
    A!
    >>> t.A
    
    >>> t.X
    2
    >>> t.Y = 23
    >>> t.X
    25
    >>> t.Z = 1
    >>> t.X
    0

    >>> t.__cells__.keys()
    ['A', 'B', 'always', 'only_on_request', 'Y', 'X', 'Z']    

Keyword arguments are accepted by the constructor::

    >>> t = Test(always=Constant(False), B=Constant(0), Z=55)
    >>> t.Z
    55
    >>> t.B
    0
    >>> t.always
    False

But not for undefined attributes::

    >>> t = Test(qqqq=42)
    Traceback (most recent call last):
      ...
    TypeError: Test() has no keyword argument 'qqqq'




XXX better error message for write to read-only cell




