======================
The Trellis Event Loop
======================

    >>> from peak.events.trellis import EventLoop
    >>> loop = EventLoop()


----------------
The "To-Do List"
----------------

Queueing Actions
================

The task framework maintains a "to-do list" or task queue for performing
arbitrary actions in the order they were requested.  The ``do()`` method
adds an action to the queue, and then performs queued actions until the queue
is empty::

    >>> def hello(*args, **kw):
    ...     print "hello", args, kw

    >>> loop.do(hello, "world!", x=42)
    hello ('world!',) {'x': 42}

As you can see, an action consists of a callable object, and arbitrary
positional and keyword arguments.  These arguments are passed to the callable
when it is invoked.

The above example isn't very interesting, because it doesn't do anything that
couldn't be done by just calling ``hello()`` in the first place.  Here's a
more interesting example, which involves more than one action::

    >>> def it():
    ...     print "before"
    ...     loop.do(hello, 1)
    ...     loop.do(hello, 2)
    ...     print "after"

    >>> loop.do(it)
    before
    after
    hello (1,) {}
    hello (2,) {}

Notice that the two "hello" calls occur *after* the ``it()`` function has
returned.  This is because ``do()`` doesn't actually perform the action, if
there is already an action being run.  Instead, the new action is queued to
execute when the current action finishes.


Co-operative Multitasking
=========================

This means that you can easily implement various kinds of co-operative
multitasking by simply requesting actions to be performed.  As long as there
is still work to be done, you can just ``do()`` the next step.  If there are
other actions going on, they are effectively scheduled in "round-robin"
fashion::

    >>> def make_counter(name, value):
    ...     def counter():
    ...         print name, counter.value
    ...         counter.value -= 1
    ...         if counter.value > 0:
    ...             loop.do(counter)
    ...         else:
    ...             print "finished", name
    ...     counter.value = value
    ...     return counter

    >>> def it():
    ...     loop.do(make_counter("foo", 6))
    ...     loop.do(make_counter("bar", 4))
    ...     loop.do(make_counter("baz", 2))

    >>> loop.do(it)
    foo 6
    bar 4
    baz 2
    foo 5
    bar 3
    baz 1
    finished baz
    foo 4
    bar 2
    foo 3
    bar 1
    finished bar
    foo 2
    foo 1
    finished foo

As you can see, each of the counters gets a "time slice" (callback) and then
requests that it be called again.  When they are all finished, the task queue
is empty, so ``do()`` returns.


Queue Status Information
========================

The ``todo()`` function returns the number of actions scheduled for execution
in the current thread, and the ``running()`` function returns a flag indicating
whether an action is currently in progress::

    >>> loop.todo()
    0
    >>> loop.running()
    False

    >>> def it():
    ...     print "running?", loop.running()
    ...     print "before", loop.todo()
    ...     loop.do(hello, 1)
    ...     print "after", loop.todo()

    >>> loop.do(it)
    running? True
    before 0
    after 1
    hello (1,) {}


You can also find out whether a particular action is queued, using the
``will_do()`` function, which returns true if given arguments that are equal
to a previous, uncompleted call to ``do()``::

    >>> loop.will_do(hello, 27)
    False

    >>> def it():
    ...     loop.do(hello, 27, y=21)
    ...     if loop.will_do(hello, 27, y=21):
    ...         print "yes!"
    ...     if loop.will_do(hello, 42, y=21):
    ...         print "I don't remember asking to do that..."
    ...     if loop.will_do(hello, 27, y=42):
    ...         print "...or that!"
    ...     if loop.will_do(int, 27, y=21):
    ...         print "What the...?"

    >>> loop.do(it)
    yes!
    hello (27,) {'y': 21}

You can also conditionally queue an action using ``do_once()``, which will only
queue the action if it is not already queued::

    >>> def it():
    ...     loop.do_once(hello, 27)
    ...     loop.do_once(hello, 27)
    >>> loop.do(it)
    hello (27,) {}


Cancelling, Exiting, and Return Values
======================================

If you want to cancel a previously-queued action, you can use ``cancel()``::

    >>> def it():
    ...     loop.do(hello, 1)
    ...     loop.do(hello, 2)
    ...     loop.do(hello, 3)
    ...     loop.cancel(hello, 2)
    >>> loop.do(it)
    hello (1,) {}
    hello (3,) {}

Cancelling a non-existent action is a no-op::

    >>> loop.cancel(hello, 2)

You can force an early exit from the ``do()`` loop and return a value by
calling the ``exit()`` function::

    >>> def it():
    ...     loop.exit(42)

    >>> loop.do(it)
    42

Note that exiting does not remove any actions from the queue::

    >>> def it():
    ...     loop.do(hello, 1)
    ...     loop.exit()

    >>> loop.do(it)
    >>> loop.todo()
    1
    >>> loop.will_do(hello, 1)
    True

But you can cancel them all by using ``clear()``::

    >>> loop.clear()
    >>> loop.todo()
    0
    >>> loop.will_do(hello, 1)
    False

If ``exit()`` isn't called, the return value of ``do()`` is the value returned
by the last action executed::

    >>> loop.do(lambda: 42)
    42




